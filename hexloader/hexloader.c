#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <avr/sleep.h>
#include <avr/power.h>
#include <avr/pgmspace.h>
#include <avr/boot.h>
#include <avr/wdt.h>
#include <util/delay.h>
#include "arch.h"

// Constants

#define VERSION                     "1.1"
#ifndef GIT_VERSION
#define GIT_VERSION
#endif
#define DEBUG

#define BAUD_RATE                   115200  //< Serial baudrate in bps
#define RX_BUFFER_LEN               256     //< receive buffer length
#define TX_BUFFER_LEN               256     //< transmit buffer length
#define LF                          10      //< \n ascii
#define CR                          13      //< \r ascii
#define ESC                         27      //< ESC ascii
#define BS                          8       //< backspace ascii
#define DEL                         127     //< delete ascii (some terminals send this instead of BS)

#define ERROR_RX_DATA_OVERRUN       1       ///< UART data overrun
#define ERROR_RX_FRAME_ERROR        2       ///< UART frame error
#define ERROR_RX_BUFFER_OVERFLOW    4       ///< UART #rx_buffer overflow

#define MODE_FLASH                  0       ///< #flash_hex_line mode (flash)
#define MODE_VERIFY                 1       ///< #flash_hex_line mode (verify)

#define FLASH_WAITING               0       ///< waiting for the first ihex line
#define FLASH_GOING_ON              1       ///< an ihex is in progress
#define FLASH_OK                    2       ///< ihex eof received and flash done ok
#define FLASH_ERROR                 3       ///< flash (eg. FCS mismatch) or verify errors

#define MAX_LINE_LEN                64      ///< 16 hex bytes/line as generated by objcopy

#define BOOTAPP_SIG_1               0xb0    // boot into app signature
#define BOOTAPP_SIG_2               0xaa

char const CRLF[] = "\r\n";

// Macros

#define SERIAL_2X_UBRRVAL(baud) ((((F_CPU / 8) + (baud / 2)) / (baud)) - 1)

/** Check if signature found in r2/r3, boot app is requested */
#define BOOT_APP() (r2 == BOOTAPP_SIG_1 && r3 == BOOTAPP_SIG_2)

/** Sleep while condition holds true.  */
#define IDLE_WHILE(condition) \
    do { \
        cli(); \
        if (condition) { \
            sei(); \
            sleep_cpu(); \
        } else { \
            sei(); \
            break; \
        } \
    } while (1);


// Variables

/**
 * Boot signature.
 * Registers r2 and r3 are used to switch between bootloader and app at
 * reset time.
 */
register uint8_t r2 asm("r2");
register uint8_t r3 asm("r3");

volatile uint8_t tx_buffer[TX_BUFFER_LEN];  ///< UART transmit buffer
volatile uint8_t rx_buffer[RX_BUFFER_LEN];  ///< UART receive buffer
volatile uint8_t rx_head, rx_tail, tx_head, tx_tail;
volatile uint8_t uart_error;                ///< one of #ERROR_RX_DATA_OVERRUN, #ERROR_RX_FRAME_ERROR or #ERROR_RX_BUFFER_OVERFLOW   
volatile uint16_t clock;                    ///< number of milliseconds since boot */
volatile uint16_t t0;
volatile int16_t breathing_led;

char line[MAX_LINE_LEN];        ///< Buffer containing hex lines or commands
uint8_t page[PAGE_SIZE];        ///< Buffer containing the current page (to be flashed or verified)
addr_t last_address;            ///< Keep track of the last address flashed
uint32_t address_extension;     ///< To be added to the address low 16 bits (02 or 04 ihex records)

///////////////////////////////////////////////////////////////////////
// ISR routines 
///////////////////////////////////////////////////////////////////////

/**
 * UART RX ISR.
 * Called when the hardware UART receives a byte.
 */
ISR(USART_RX_vect)
{
    // UCSR0A must be read before UDR0
    uint8_t status = UCSR0A;
    uint8_t data = UDR0;    // this clears the interrupt flag
    uint8_t new_head = (rx_head + 1) % RX_BUFFER_LEN;

    if (status & _BV(DOR0))
        uart_error |= ERROR_RX_DATA_OVERRUN;
    if (status & _BV(FE0))
        uart_error |= ERROR_RX_FRAME_ERROR;

    // If head meets tail -> overflow and ignore the received byte
    if (new_head == rx_tail) {
        uart_error |= ERROR_RX_BUFFER_OVERFLOW;
    }
    else {
        rx_buffer[rx_head] = data;
        rx_head = new_head;
    }
    // delay watchdog reboot while pending rx data
    wdt_reset();
}

/**
 * UART Data Register Empty ISR.
 * Called when the UART is ready to accept a new byte for transmission.
 */
ISR(USART_UDRE_vect)
{
    if (tx_head == tx_tail) {
        // Buffer is empty, disable UDRE int
        UCSR0B &= ~_BV(UDRIE0);
    }
    else {
        // Send byte
        UDR0 = tx_buffer[tx_tail];
        tx_tail = (tx_tail + 1) % TX_BUFFER_LEN;
    }
    // delay the reboot until no more pending tx
    wdt_reset();
}

/**
 * Timer 0 comparator A ISR.
 * Called when timer 0 counts up to OCR0A. This is used to keep track
 * of time and also for the breathing LED (software PWM).
 */
ISR(TIMER0_COMPA_vect)
{
    uint16_t c = ++clock;
    
    LED_ON();
    if ((c % 8) == 0) {
        // breath in the lower half brightness range of the led (0 .. OCR0A / 2)
        if (++breathing_led > OCR0A) breathing_led = 0;
        if (breathing_led < OCR0A / 2)
            OCR0B = breathing_led;
        else
            OCR0B = OCR0A - breathing_led;
    }
}

/**
 * Time 0 comparator B ISR.
 * Called when timer 0 counts up to OCR0B. This is used for the breathing
 * LED (software PWM). It is declared naked because it doesn't change
 * registers or SREG.
 */
ISR(TIMER0_COMPB_vect, ISR_NAKED)
{
    LED_OFF();
    reti();
}

/**
 * SPM ready ISR.
 * Called when the SPM instruction is done. It just disables SPMIE
 * so that it doesn't get called infinitely.
 */
ISR(SPM_READY_vect)
{
    boot_spm_interrupt_disable();
}


///////////////////////////////////////////////////////////////////////
// Conversion utils
///////////////////////////////////////////////////////////////////////

/**
 * Decode n hex big endian nibbles.
 */
uint16_t hex_nibbles(char *s, uint8_t n)
{
    uint16_t r = 0;
    while (n) {
        r <<= 4;
        if (*s >= '0' && *s <= '9')
            r += *s - '0';
        else if (*s >= 'A' && *s <= 'F')
            r += *s - 'A' + 10;
        else if (*s >= 'a' && *s <= 'a')
            r += *s - 'a' + 10;
        s++;
        n--;
    }
    return r;
}


///////////////////////////////////////////////////////////////////////
// Timing functions 
///////////////////////////////////////////////////////////////////////

/**
 * Start the timer.
 * Use the timer in CTC (clear timer on compare) mode to count up to OCR0A
 * and generate interrupts on both OCR0A/OCR0B matches.
 *
 * With a prescaler = 64, OCR0A = 249 and CPU clock = 16 MHz, the period
 * is 0.996ms (~ 1ms).
 */
void timer_init(void)
{
    TCCR0A = _BV(WGM01);                // CTC mode (count up to OCR0A)
    OCR0A = 249;                        // 249 * 64 / 16M = 0.996 ms
    TCCR0B = _BV(CS01) | _BV(CS00);     // clk/64 prescaler
    TIMSK0 = _BV(OCIE0A) | _BV(OCIE0B); // Interrupt on both A, B match
}

/**
 * Current time in ms.
 * @return the number of milliseconds since reset
 */
uint16_t millis(void)
{
    uint16_t m;
    cli();      // read atomically
    m = clock;
    sei();
    return m;
}


///////////////////////////////////////////////////////////////////////
// UART functions
///////////////////////////////////////////////////////////////////////

/**
 * Start the UART.
 * Set the UART to 2x speed mode, BAUD_RATE bauds, 8N1 and enable rx 
 * interrupts.
 */
void uart_init(void)
{
    // Set baud rate
    UBRR0 = SERIAL_2X_UBRRVAL(BAUD_RATE);

    // double speed
    UCSR0A = _BV(U2X0);

    // 8,N,1
    UCSR0C = (3 << UCSZ00);

    // Enable receiver and transmitter, generate interrupts on RX, DRE
    UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
}

/**
 * Send a byte.
 * If the tx queue is full, it will sleep (ie. block) until space becomes
 * available.
 * @param c the byte
 */
void uart_send_byte(uint8_t c)
{
    uint16_t new_head = (tx_head + 1) % TX_BUFFER_LEN;

    IDLE_WHILE(tx_tail == new_head);

    tx_buffer[tx_head] = c;
    tx_head = new_head;

    // Enable UDRE int, this will trigger the UDRE ISR
    UCSR0B |= _BV(UDRIE0);
}

/**
  * Flush the tx buffer.
  */
void uart_flush(void)
{
    IDLE_WHILE(tx_tail != tx_head);
}

/**
 * Send a PROGMEM string.
 * @param s the string, which *must* be in program space
 */
void uart_send_string(char const s[])
{
    char c;
    while ((c = *(s++)))
        uart_send_byte(c);
}

/**
 * Send a uint32_t in decimal format.
 * @param x the uint32_t value
 */
void uart_send_int(uint32_t x)
{
    if (x < 10)
        uart_send_byte(x + '0');
    else {
        uart_send_int(x / 10);
        uart_send_byte(x % 10 + '0');
    }
}

/**
 * Print out n lower nibbles of x in big endian hexadecimal.
 * @param x x
 * @param n number of nibbles
 */
void uart_send_hex(uint16_t x, uint8_t n)
{
    if (n != 0) {
        uart_send_hex(x >> 4, n - 1);
        x &= 0xf;
        if (x >= 0 && x <= 9)
            uart_send_byte(x + '0');
        else
            uart_send_byte(x + 'A' - 10);
    }
}

/**
 * Receive a byte.
 * @return an int16_t with the byte, will block until data is available.
 */
uint8_t uart_recv_byte(void) 
{
    IDLE_WHILE(rx_tail == rx_head);

    int8_t c = rx_buffer[rx_tail];
    rx_tail = (rx_tail + 1) % RX_BUFFER_LEN;

    return c;
}

/**
 * Check if there is incoming data over the UART.
 * @return true if data available
 */
int8_t uart_available(void)
{
    return (rx_tail != rx_head);
}


///////////////////////////////////////////////////////////////////////
// Reboot functions
///////////////////////////////////////////////////////////////////////

/** Force a reboot.
 * Reboots the AVR by setting the watchdog timer. Interrupts are
 * allowed, so that pending rx or tx data gets flushed.
 */
void __attribute__((noreturn)) reboot(void) {
    // There is a 70-90 ms bluetooth 'silence' after the 1 KB or so is
    // received. In order to flush a possibly long paste, set the watchdog
    // timer to reboot after 120 ms of inactivity.
    wdt_enable(WDTO_120MS);
    for (;;) {
        sleep_cpu();
    }
}

/** Reboot to bootloader.
 * Sets a 15 ms watchdog timer and idles until the watchdog reboots
 * the AVR. Registers r2 = r3 = 0 are used to signal bootloader run.
 */
void __attribute__((noreturn)) reboot_to_bootloader(void)
{
    uart_send_string(P("Rebooting into bootloader\r\n\r\n"));
    r2 = r3 = 0;
    reboot();
}

/** Reboot to user app.
 * Sets a 15 ms watchdog timer and idles until the watchdog reboots
 * the AVR. Registers r2/r3 = 0xb0aa are used to signal app run.
 */
void __attribute__((noreturn)) reboot_to_app(void)
{
    uart_send_string(P("Enjoy!\r\n\r\n"));
    r2 = BOOTAPP_SIG_1;
    r3 = BOOTAPP_SIG_2;
    reboot();
}


///////////////////////////////////////////////////////////////////////
// Input parsing
///////////////////////////////////////////////////////////////////////

/**
 * Get a line of #MAX_LINE_LEN max bytes.
 * @return 1 if there is a valid line in the #line buffer.
 */
uint8_t get_line(void)
{
    static uint8_t len = 0;
    uint8_t c;

    if (uart_error & ERROR_RX_BUFFER_OVERFLOW) {
        uart_send_string(P("\r\nUART error: buffer overflow (try a lower baud rate)\r\n"));
        reboot_to_bootloader();
    }
    // Ignore frame errors
#if 0
    if (uart_error & ERROR_RX_FRAME_ERROR) {
        uart_send_string(P("\r\nUART error: frame error\r\n"));
        reboot_to_bootloader();
    }
#endif
    if (uart_error & ERROR_RX_DATA_OVERRUN) {
        uart_send_string(P("\r\nUART error: data overrun\r\n"));
        reboot_to_bootloader();
    }

    c = uart_recv_byte();
    if (c == ESC) {
        uart_send_string(P(CRLF));
        line[0] = '\0';
        len = 0;
        return 1;
    }
    else if (c == BS || c == DEL) {   // backspace
        if (len > 0) {
            len--;
            uart_send_byte(BS);
        }
    }
    else if (c == CR || c == LF) {
        line[len] = '\0';
        if (len > 0) {
            len = 0;
            if (line[0] != ':') {   // no echo if receiving hex
                uart_send_string(P(CRLF));
            }
            return 1;
        }
    }
    else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == ':') {
        if (len < MAX_LINE_LEN - 1) {
            line[len++] = c;
            if (line[0] != ':') {   // no echo if receiving hex
                uart_send_byte(c);
            }
        }
        else if (len == MAX_LINE_LEN - 1) {
            line[len++] = '\0';
        }
    }

    return 0;
}

/**
 * Show a comand prompt.
 */
void prompt(void)
{
    uart_send_string(P(">: "));
}


///////////////////////////////////////////////////////////////////////
// Flashing functions
///////////////////////////////////////////////////////////////////////

/** Point out an error with carets.
 * @param col the column to point out
 * @param carets the number of carets
 */
void point_out_error(uint8_t col, uint8_t carets)
{
    int i;
    for (i = 0; i < col; i++)
        uart_send_byte(' ');
    for (i = 0; i < carets; i++)
        uart_send_byte('^');
    uart_send_string(P(CRLF));
}

/**
 * Dump an ihex encoded line.
 */
void dump_line(void)
{
    int i;
    for (i = 0; line[i]; i++) {
        uart_send_byte(line[i]);
    }
    uart_send_string(P(CRLF));
}

/**
 * Empty the current page with 0xff (nop).
 */
void new_page(void)
{
    int i;
    for (i = 0; i < PAGE_SIZE; i++)
        page[i] = 0xff;
}

/**
 * Flash the current page.
 * Writes the current page at #current_page from the data in
 * the #page buffer.
 */
void write_current_page(addr_t current_page)
{
    const addr_t addr = current_page * PAGE_SIZE;
    uint16_t i;

    // All operations involving SPM are timed sequences and must be protected
    // from interrupts with cli()/sei(), ie. boot_page_*.
    cli();
    boot_page_erase(addr);          // erase page
    boot_spm_interrupt_enable();    // let SPM-ready interrupt wake us up
    sei();

    IDLE_WHILE(boot_spm_busy());    // sleep until SPM is done

    for (i = 0; i < PAGE_SIZE; i += 2) {
        // make little endian words by swapping every two bytes
        uint16_t word = page[i] | (page[i+1] << 8);
        cli();
        boot_page_fill(addr + i, word);
        // no need to IDLE_WAIT(boot_spm_busy()) here
        sei();
    }

    cli();
    boot_page_write(addr);          // write page
    boot_spm_interrupt_enable();    // let SPM-ready int wake us up
    sei();

    IDLE_WHILE(boot_spm_busy());    // sleep until SPM done
}

/**
 * Validate an address.
 * Addresses in the ihex file must start at 0 and be monotonically 
 * increasing.
 * @param last_address last address
 * @param address currant address
 * @return true if valid
 */
uint8_t is_address_valid(addr_t address) 
{
    if (address >= NRWW_START) {
        uart_send_string(P("\r\nProgram too big:\r\n"));
        dump_line();
        point_out_error(3, 4);
        return 0;
    }

    if (last_address == -(addr_t)1 && address != 0) {
        uart_send_string(P("\r\nFirst address must be 0:\r\n"));
        dump_line();
        point_out_error(3, 4);
        return 0;
    }

    if (last_address != -(addr_t)1 && address < last_address) {
        uart_send_string(P("\r\nAddresses must be increasing:\r\n"));
        dump_line();
        point_out_error(3, 4);
        return 0;
    }
    return 1;
}

/**
 * Display progress.
 * @param mode either #MODE_FLASH or #MODE_VERIFY
 * @param count bytes flashed/verified
 */
void progress(uint8_t mode, addr_t count)
{
    if (mode == MODE_FLASH) {
        uart_send_string(P("\rFlashed "));
    }
    else {
        uart_send_string(P("\rVerified "));
    }
    uart_send_int(count);
}

/**
 * Verify checksum on line
 * @return true if valid
 */
int8_t is_checksum_valid(void)
{
    int i;
    uint8_t checksum = 0;
    for (i = 1; line[i] && line[i+1]; i += 2) {
        checksum += hex_nibbles(line + i, 2);
    }
    return checksum == 0;
}


/**
 * Decode an hex line and flash if we have PAGE_SIZE bytes already.
 * @return flash status (#FLASH_GOING_ON, #FLASH_OK, #FLASH_ERROR)
 */
uint8_t flash_hex_line(uint8_t mode)
{
    uint16_t address;
    uint8_t count;
    uint8_t record_type;
    int i;

    if (! is_checksum_valid()) {
        uart_send_string(P("\r\nChecksum error in line:\r\n"));
        dump_line();
        return FLASH_ERROR;
    }

    count = hex_nibbles(line + 1, 2);
    address = hex_nibbles(line + 3, 4);
    record_type = hex_nibbles(line + 7, 2);

    if (count > 16) {
        uart_send_string(P("\r\nRegisters >16 bytes not supported\r\n"));
        dump_line();
        point_out_error(1, 2);
        return FLASH_ERROR;
    }

    if (record_type == 0x04) {      // Extended Linear Address record
        address_extension = (uint32_t) hex_nibbles(line + 9, 4) << 16;
    }

    else if (record_type == 0x02) { // Extended Segment Address record
        address_extension = (uint32_t) hex_nibbles(line + 9, 4) << 4;
    }

    else if (record_type == 0x01) {     // End of file record
        if (mode == MODE_FLASH) {
            // flush the current page
            write_current_page(last_address / PAGE_SIZE);

            // re-enable RWW area
            cli();
            boot_rww_enable();
            boot_spm_interrupt_enable();
            sei();
            IDLE_WHILE(boot_spm_busy());
        }
        // prepare for verify: reset address extension
        address_extension = 0;
        return FLASH_OK;
    }

    else if (record_type == 0x00) {     // Data record
        uint32_t extended_address = address + address_extension;

        if (! is_address_valid(extended_address))
            return FLASH_ERROR;

        for (i = 0; i < count; i++) {
            uint8_t b = hex_nibbles(line + 9 + i * 2, 2);

            if (mode == MODE_FLASH) {
                addr_t last_page = last_address / PAGE_SIZE;
                addr_t current_page = (extended_address + i) / PAGE_SIZE;
                if (last_page != current_page && last_address != -(addr_t)1) {
                    // current page is ready to write
                    write_current_page(last_page);
                    new_page();
                }
                page[(address + i) % PAGE_SIZE] = b;
            }
            else {  // MODE_VERIFY
                if (R(extended_address + i) != b) {
                    uart_send_string(P("\r\nHex and flash mismatch:\r\n"));
                    dump_line();
                    point_out_error(9 + i * 2, 2);
                    return FLASH_ERROR;
                }
            }
            last_address = extended_address + i;
        }
        progress(mode, last_address + 1);
   
    }

    return FLASH_GOING_ON;
}

/**
 * Dump the entire flash contents.
 */
void dump_flash(void)
{
    uint8_t checksum = 0;
    addr_t address;
    for (address = 0; address < FLASH_SIZE; address++) {
        uint8_t b;
#if FLASH_SIZE > 65536
        if (address % 0x10000 == 0) {
            // Emit a 04 record (extended linear address) on 16-higher-bits change
            uint16_t segment = address >> 16;
            uart_send_string(P("\r\n:02"));
            uart_send_hex(0x0000, 4);       // address (16 bit), ignored
            uart_send_hex(0x04, 2);         // record type 04
            uart_send_hex(segment, 4);      // segment
            checksum = - 0x02 - 0x04 - (segment >> 8) - (segment & 0xff);
            uart_send_hex(checksum, 2);
        }
#endif
        if (address % 16 == 0) {
            uart_send_string(P("\r\n:10"));
            uart_send_hex(address, 4);
            uart_send_hex(0, 2);
            checksum = - 0x10 - (address >> 8) - (address & 0xff);
        }
        b = R(address);
        uart_send_hex(b, 2);
        checksum -= b;
        if (address % 16 == 15) {
            uart_send_hex(checksum, 2);
        }
    }
    uart_send_string(P("\r\n:00000001FF\r\n"));
}


///////////////////////////////////////////////////////////////////////
// Bootloader sequence
///////////////////////////////////////////////////////////////////////

/**
 * Parse the last entered line and run a command.
 */
void run_command(void)
{
    switch(line[0]) {
        case 'q':
            reboot_to_app();
            break;
        case 'r':
            reboot_to_bootloader();
            break;
        case 'd':
            dump_flash();
            prompt();
            break;
        case 'h':
            uart_send_string(P(
                " q\treboot to app\r\n"
                " r\treboot to bootloader\r\n"
                " d\tdump flash in hex format\r\n"
                " esc\tabort current command\r\n"
            ));
            prompt();
            break;
        case '\0':
            prompt();
            break;
        default:
            uart_send_string(P("'h' for help\r\n"));
            prompt();
            break;           
    }
}

/**
 * Bootloader sequence.
 */
void __attribute__((noreturn)) bootloader(void)
{
    uint8_t flash_status;
    uint8_t mode;

    // Move ISR vector table to the bootloader
    MCUCR = _BV(IVCE);
    MCUCR = _BV(IVSEL);

    // init led pin direction
    INIT_LED();

    // init sleep mode, uart and timer
    power_init();
    uart_init();
    timer_init();
    sei();

    // prepare a new empty page
    new_page();

    // Run through the two modes: first flash, then verify
    for (mode = MODE_FLASH; mode <= MODE_VERIFY; mode++) {
        if (mode == MODE_FLASH) {
            uart_send_string(P(
                "AVR Hexloader " VERSION " git " GIT_VERSION "\r\n"
                "Paste your hex file, 'h' for help\r\n"));
        }
        else {
            uart_send_string(P("Paste again to verify\r\n"));
        }
        prompt();

        new_page();
        last_address = -(addr_t)1;
        flash_status = FLASH_WAITING;
        do {
            if (get_line()) {
                if (line[0] == ':') {
                    if (flash_status == FLASH_WAITING) {
                        t0 = millis();
                    }
                    flash_status = flash_hex_line(mode);
                }
                else {
                    run_command();
                }
            }
        } while (flash_status == FLASH_GOING_ON || flash_status == FLASH_WAITING);

        if (flash_status != FLASH_OK) {
            reboot_to_bootloader();
        }

        uart_send_string(P(" OK! ("));
        uart_send_int(millis() - t0);
        uart_send_string(P("ms)\r\n"));
    }
    reboot_to_app();
}

/**
 * Entry point.
 * Decides whether to run the bootloader or the user app.
 */
void __attribute__((noreturn)) main(void) {
    // Disable the watchdog if set
    uint8_t mcusr = MCUSR;
    if (mcusr & _BV(WDRF)) {
        MCUSR = mcusr & ~_BV(WDRF);
        wdt_disable();
    }

    // Boot into app if
    // (just powered on (no external or watchdog reset), 
    // OR bootloader 0xb0aa signature found (boot into app))
    // AND (program memory is not empty)
    if ((!(mcusr & (_BV(EXTRF) | _BV(WDRF))) || BOOT_APP())
            && pgm_read_word_near(0) != 0xffff) {
        r2 = r3 = 0;
        asm("jmp 0");               // go to app
        __builtin_unreachable();    // suppress 'noreturn does return' warning
    }
    else {
        r2 = BOOTAPP_SIG_1;
        r3 = BOOTAPP_SIG_2;
        bootloader();
    }
}
